### 프로그래머스\고득점kit\힙\디스크컨트롤러

---

<br/>

## Question

[디스크컨트롤러 문제 바로가기](https://school.programmers.co.kr/learn/courses/30/lessons/42627)

<br/>

## Solve

```java
import java.util.*;

class Solution {
  public int solution(int[][] jobs) {
    // 작업 요청 순서 오름차순 정렬
    jobs = quickSort(jobs, 0, jobs.length-1);

    // 우선순위 큐 (소요 시간 오름차순)
    // 두 디스크가 시작 시점이 같다면 먼저 시작하는 디스크가 빨리 끝날 수록 각 처리시간의 합이 짧아짐.
    PriorityQueue<int[]> q = new PriorityQueue<>((x, y) -> x[1] - y[1]);

    int total = 0; // 처리시간 총합
    int cnt = 0;   // 처리 횟수
    int idx = 0;   // jobs의 인덱스
    int end = 0;   // 끝난 시점

    while (cnt < jobs.length) {

      // 현재 디스크가 끝나는 시점보다 빨리 요청된 디스크는 큐에 넣는다.
      while (idx < jobs.length && jobs[idx][0] <= end) {
        q.add(jobs[idx++]);
      }

      // 아직 모든 요청이 완료되지 않았는데 시작할 디스크가 없는 경우 = 요청시간이 end 시점보다 뒤인 경우
      if (q.isEmpty()) {
        end = jobs[idx][0]; // 해당 디스크의 시작 시점으로 맞춰준다 (다음 반복 때 큐에 들어가게 됨)
      } else {
        int[] cur = q.poll();
        end += cur[1];
        total += end - cur[0];
        cnt++;
      }
    }

    return total / jobs.length;

  }

  // 퀵정렬
  public int[][] quickSort(int[][] a, int start, int end) {
    int left = start;
    int right = end;
    int pivot = a[(left+right)/2][0]; // 타겟 : 작업 요청 시간

    do {
      while (a[left][0] < pivot) left++;
      while (a[right][0] > pivot) right--;
      if (left <= right) {
        int[] tmp = a[left];
        a[left] = a[right];
        a[right] = tmp;
        left++; right--;
      }
    } while (left <= right);

    if (left < end) quickSort(a, left, end);
    if (start < right) quickSort(a, start, right);

    return a;
  }
}
```

<br/>

## Note

#### **우선순위 큐 기준 지정**

**Integer**

```java
// 낮은 숫자 순으로 우선순위 결정
PriorityQueue<Integer> priorityQueue1 = new PriorityQueue<>();

// 높은 숫자 순으로 우선순위 결정
PriorityQueue<Integer> priorityQueue2 = new PriorityQueue<>(Collections.reverseOrder());

// 낮은 숫자 순으로 우선순위 결정
PriorityQueue<String> priorityQueue3 = new PriorityQueue<>();

// 높은 숫자 순으로 우선순위 결정
PriorityQueue<String> priorityQueue4 = new PriorityQueue<>(Collections.reverseOrder());
```

<br/>

**int[]**

```java
// 낮은 숫자 순으로 우선순위
PriorityQueue<int[]> q = new PriorityQueue<>((x, y) -> x[1] - y[1]);

// 또다른 방법
PriorityQueue<int[]> pq = new PriorityQueue<>(new Comparator<int[]>() {
  @Override
  public int compare(int[] o1, int[] o2) {
    // 만일 2차원 배열의 첫 번째 원소가 같다면, 2번째 원소를 기준으로 내림차순 정렬한다.
    if(o1[0] == o2[0]) {
      return Integer.compare(o2[1], o1[1]);
    }
    // 2차원 배열의 첫 번째 원소를 기준으로 오름차순 정렬한다.
    return Integer.compare(o1[0], o2[0]);
  }
});
```
