### 프로그래머스\고득점kit\스택큐(리스트로 풀이)\프로세스

---

<br/>

## Question

[프로세스 문제 바로가기](https://school.programmers.co.kr/learn/courses/30/lessons/42587)

<br/>

## Solve

### 원형 리스트 직접 구현해서 풀어보기

```java
// 노드
class NodeBi {
  int data;
  NodeBi next;
  NodeBi prev;
  NodeBi(int data, NodeBi next, NodeBi prev) {
    this.data = data;
    this.next = next;
    this.prev = prev;
  }
}

// 원형 연결리스트 구현
class CircularLinkedList {
  NodeBi head;
  NodeBi tail;

  NodeBi target;
  int targetIdx;
  int targetValue;

  int cnt;
  int elemCnt;

  int minOfBigger = 10;
  int max = 0;

  CircularLinkedList(int targetIdx, int targetValue) {
    this.targetIdx = targetIdx;
    this.targetValue = targetValue;
    this.cnt = 1;
  }

  // 데이터 추가
  public void addData(int data, int i) {
    // target 보다 작은 수는 무시
    if (targetValue > data) {
      return;
      // target 보다 큰 수 중에 가장 작은 수, 최대값 구하기 (최대값부터 target 바로 직전까지 지워주는 작업)
    } else if (targetValue < data) {
      this.minOfBigger = Math.min(data, minOfBigger);
      this.max = Math.max(data, max);
    }

    // 리스트가 비어있는 경우
    if (this.head == null) {
      this.head = new NodeBi(data, null, null);
      this.tail = this.head;
      this.head.prev = this.tail;
      this.tail.next = this.head;
      this.elemCnt++;

      // tail 뒤에 추가
    } else {
      this.tail = new NodeBi(data, this.head, this.tail);
      this.head.prev = this.tail;
      this.tail.prev.next = this.tail;
      this.elemCnt++;
    }
    // 만약 target 데이터면 target 노드에 저장
    if (targetIdx == i) target = this.tail;
  }

  // target 데이터와 같은 값을 제외하고 순서대로 지워줌
  public void removeData() {
    // 배열에 다 같은 수만 있던 경우
    if ((max == 0) && (minOfBigger == 10)) {
      // 값이 하나인 경우
      if (elemCnt == 1) {
        return;
      }
      // 그렇지 않은 경우
      cntData(this.head);
      return;
    }

    // target 데이터의 값보다 큰 수가 있는 경우
    NodeBi cur = this.head;   // 삭제할 데이터 위치
    NodeBi pre = cur.prev;    // cur 바로 이전에서 따라다니는 노드
    NodeBi point = cur.next;  // i-- 될 때마다 다시 시작하는 위치 (큰 수를 다 지운 후 count 의 시작 위치
    NodeBi spot = pre;        // 다시 시작하는 위치의 바로 직전 위치 (한 바퀴의 기준)

    for (int i = max; i >= minOfBigger; i--) {
      do {
        if (cur.data == i) {
          // 남은 노드가 두개인 경우
          if (cur.next == pre) {
            this.cnt++;
            return;
          }
          // 남은 노드가 세개 이상인 경우
          cur.next.prev = pre;
          pre.next = cur.next;
          point = cur.next;
          if (cur == head) this.head = cur.next;
          this.cnt++;
        }
        cur = cur.next;
        pre = cur.prev;
      } while (cur != spot);

      // spot 에 해당하는 데이터 확인
      if (cur.data == i) {
        // 남은 노드가 두개인 경우
        if (cur.next == pre) {
          this.cnt++;
          return;
        }
        // 남은 노드가 세개 이상인 경우
        cur.next.prev = pre;
        pre.next = cur.next;
        point = cur.next;
        this.cnt++;
      }
      cur = point;
      pre = cur.prev;
      spot = pre;
    }
    cntData(point);
  }

  public void cntData(NodeBi point) {
    // target 이 바로 나오는 경우
    if ((point == target) || (elemCnt == 1)) {
      return;
    }

    // target 이 바로 나오지 않는 경우
    do {
      this.cnt++;
      point = point.next;
    } while (point != target);
  }
}

class Solution {
  public int solution (int[] priorities, int location) {
    CircularLinkedList list = new CircularLinkedList(location, priorities[location]);

    for (int i = 0; i < priorities.length; i++) {
      list.addData(priorities[i], i);
    }
    list.removeData();

    return list.cnt;
  }
}
```

<br/>

## Memo

<img src="https://github.com/JGoo99/CodingTest/assets/126454114/16bac876-b208-4a2e-858d-5a4b55e4102f" width="50%" height="50%"/>

> 몇 번이나 갈아엎고 겨우 성공했던 문제,,
>
> 처음 풀었을 땐 원형리스트에 target 데이터와 일치하는 수만 집어넣었다가 정확성 70프로로 헤매다가 위 방법 처럼 바꾸었다.
>
> > **풀이방법**
>
> > 1. target 데이터보다 작은 수를 제외하고는 전부 원형리스트에 순서대로 넣는다.
>
> > 2. 리스트의 가장 큰 수부터 차례대로 지우면서 target 데이터와 크기가 같은 노드만 남긴다.
>
> > 3. 남은 노드들을 카운트한다.
>
> 이때 주의할 점은 한바퀴 돌고 가장 큰 수를 다 지웠으면 head 부터 다시 도는게 아니라 **마지막으로 지웠던 노드 위치의 바로 다음 노드부터 시작해야 한다!**

<br/>

## Note

> 연결리스트 개념을 어제 처음 배웠는데 Node 가 아직 너무 어색했다.
>
> 익숙해지기 위해 해당 문제에 실습을 진행하였고, 현재는 꽤나 익숙해졌다!
>
> 근데 연결리스트 API를 사용할 줄 모른다...ㅋㅋㅋ 다음 문제 때는 api에 익숙해져보아야 겠다!
